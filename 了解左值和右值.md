### C++中的左值，亡值以及纯右值
C++11中对于表达式的值的类别进行了重新定义，表达式的值类别只有三种基本类别**左值**，**亡值**，以及**纯右值**，并且左值可以和亡值组成泛左值，亡值可以和纯右值组成右值

#### 左值
左值就是可以取地址的对象，代表了一个具名的，持久存在的对象和函数，也是最基础的，最常见的表达式类别之一
常见形式为变量名，函数或成员函数调用，数组元素，左值类内的对象的访问，解引用指针，字符串字面量等
左值有几个特殊的特性
+ 左值引用只能绑定到左值上
+ const左值不可修改，但可取地址
+ 左值在一些情况下可以隐式转换成右值

#### 右值
与左值相似，右值就是不可以取地址的对象，代表了临时对象和可以被移动的值
右值有几个特殊的特性
+ 右值通常是临时对象，或即将销毁的值
+ 不可取地址
+ 生命周期短暂

在C++11后被分为亡值和纯右值，这里主要先介绍纯右值
纯右值表示纯粹的临时值，例如
+ 字面量，20,“hello world”
+ 函数调用返回非引用的值
+ 算术表达式效果


#### 亡值
亡值是表示资源即将被销毁但可以被移动的表达式
那什么时候表达式是亡值呢
在文献中是这么说的
>一个表达式是亡值如果它是：
>    + 调用函数的结果，且无论是隐式还是显式，其返回类型是对象类型的右值引用，
>    + 转换到对象类型的右值引用，
>    + 带有亡值数组操作数的（内建）下标运算，
>    + 类成员访问表达式，且该成员是非引用类型的非静态数据成员，并且对象表达式是亡值，或者
>    + .* 指向成员的指针表达式，其中第一个操作数是亡值，第二个操作数是指向数据成员的指针。

>通常，此规则的效果是具名右值引用被视为左值，而对对象的不具名右值引用被视为亡值；无论是否具名，对函数的右值引用都被视为左值。
这里再逐条对上面说的进行解释
+ 一个函数返回右值引用，此时调用函数获得的就是亡值
+ 将表达式进行转换，转换成右值引用，此时就是亡值
+ 当数组本身是亡值时，对其下b运算
+ 对象表达式是亡值，访问对象的非静态，非引用类型的成员

亡值是移动语义的基础，通过将对象标记为亡值，进而调用移动构造函数，转移资源的使用权，减少拷贝的消耗

### 左值引用
左值引用就是对左值的引用，用法类似于指针，主要目的是为了减少拷贝，直接引用对象
   
    //实例
    int a = 10;
    int& b = a;

左值引用在通常情况下是不能引用右值的，但const修饰的左值引用既可以引用左值，也可以引用右值
>原因：const左值引用，本意上是指向一个不被它修改的内存区域，本质上这个引用变量本身也就是一个常量，而具体这个内存是什么变量就无所谓了

### 右值引用
右值引用就是对右值的引用，主要作用是**延长对象的生命周期，一般是延长到作用域的范围之外

    //实例
    int&& a = 10;
    int&& b = x + y;

同左值一样，右值引用在通常情况下只能引用右值，不能直接引用左值，但右值引用可以引用被move的左值
>move是C++11引入的一个函数，可以将一个左值强制转换成右值，继而被右值引用所引用

>右值被引用成为右值引用后，此时右值引用就有自己的存储位置，也就变成了左值，可以进行取地址和赋值，注意取出来的地址和赋值操作都只是对右值引用的取址及改变，（特）当右值引用作为函数返回值返回时是右值，就是还未有名字时

#### 简述
左值引用的实际意义在于做参数和返回值都可以减少拷贝，从而提高效率，但也有其局限性，就是不能引用局部变量，例如当函数将一个函数内部定义的局部变量返回后，在函数结束后就会销毁，如果再想引用使用就会报错，于是就添加了右值引用，比如移动构造函数
这里做一个简单的辨析，对于拷贝构造和移动构造
当使用=试图进行构造时，编译器会先判断传进来的表达式是左值还是右值，如果是左值，那就调用拷贝构造，如果是右值，那就调用移动构造（减少拷贝次数）

### 完美转发

+ 万能引用
在确定类型的&&表示右值引用，如int&&，string&&，但在函数模板中的&&不表示右值引用，而是万能引用，模板类型必须通过推断才能进行，当其接受左值后会被推导为左值引用，接受右值后会被推导为右值引用

然而在实际应用中，当使用了右值引用引用右值后，他的属性就变成了左值，因为前面讲过，右值引用本身是一个左值，这样在传参的过程中，右值失去了原有的属性，导致实际的推导失败，于是C++就又提供了一个函数*forward*，用来实现完美转发，它在传参的过程中保留对象的原声类型属性，这样右值引用在传递过程就能保持右值的属性
