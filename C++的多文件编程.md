### 前话
在写本篇文章之前，我一直使用的是*一个文件*编程，换言之，就是一个文件就是一个程序，一整个顺序流程，我个人认为写起来很舒服，想些什么就加上什么，不用考虑文件之间的相互引用，但最近突然看到在一个小组的同学写的项目，他使用了多个文件，放在一个文件夹中，而主程序只用了不到十行，我看到感到震惊，一方面震惊于未知的知识，更震惊于代码的简洁，各个对象放在不同的文件中，排列有序，感受到了代码之美，于是也就有了这篇文章。

### 声明与定义
在具体的多文件实现前，先介绍两个关键的定义
+ 声明 ： 告诉编译器某个函数或变量的存在，并不分配内存
***
    //变量声明
    extern int num;

    //函数声明
    int add(int a, int b);

    //类声明
    class Person {
    public:
        void introduce(); 
    };
***
+ 定义 ： 为函数，变量，类分配内存，并提供具体的实现
***
    //变量定义
    int num = 10;

    //函数定义
    int add(int a, int b) { 
        return a + b;
    }
    
    //类成员的定义
    #include <iostream>
    #include "Person.h"

    // 成员函数定义
    void Person::introduce() {
        std::cout << "Hi, I'm a person." << std::endl;
    }
***
这里需介绍几种特殊情况
1. 在头文件中可以定义const对象，原因在于全局const默认是非extern的，也就是静态变量，只能为包含它的文件使用，同理，所有的由static修饰的对象也可以放进头文件中
2. 在头文件中可以定义类，原因在于编译器遇到类时，需要知道这个类具体是怎样的，该如何分配内存，所以通常的做法是将类的定义放在头文件中，把成员函数的实现代码放在一个.cpp文件中

### 文件组成

一个C++的项目通常包含两类文件，一类是.hpp，一类是.cpp，还有main.cpp，.hpp被称为头文件，.cpp被称为源文件，通常在hpp中放入各类声明，cpp中放入具体的实现，也就是定义，main.cpp放程序的入口，调用模块文件

### 可执行文件的生成

一个C++代码变成可执行的文件（编译的过程），通常需要以下步骤，
1. 预处理 处理以#开头的指令，如#include #define 将头文件的内容插入到源代码中并展开宏定义，经过预处理的文件后缀为.i
2. 编译 将代码转换成汇编语言，通常编译器会在这步对不同的语法进行优化，以提升运行效率，此步骤后的文件为.s
3. 汇编 将汇编代码转换成机器语言，生成.o文件
4. 链接 链接器将多个目标文件和库文件合并，解决符号引用，生成最终的可执行文件
>其实还有一步，链接器将所有机器代码组织成操作系统能识别的可执行文件

为什么引用了头文件，就可以直接使用，其关键就在于编译与汇编这两个步骤，在编译时，编译器会生成一个符号表，而在链接阶段，编译器就会在连接的文件中去寻找每一个符号，一旦找到了，就可以顺利的生成可执行文件了

### 避免头文件重复引用

在实际编程时，我们可能在两个源文件中同时引用头文件，而这就会造成重复定义的错误，这介绍几个避免这类问题的方法
+ 使用#ifndef预处理指令
***
    //在头文件前加入
    #ifndef HAHAHA
    #define HAHAHA
    //结尾加入
    #endif
原理 第一次包含头文件时，未定义了HAHAHA,就会defineHAHAHA,第二次包含时，由于已经定义了HAHAHA,头文件不会被展开，就避免了重复定义
>推荐使用
+ 兼容性高 ：#ifndef 是 C 和 C++ 标准支持的方式，适用于所有编译器（GCC、Clang、MSVC 等
+ 防止全局作用域污染 ： 头文件可能会被多个不同的 .cpp 文件包含，如果没有保护宏，每次 #include 这个头文件时，都会重新编译头文件的内容，头文件保护宏确保只展开一次，不会影响其他 .cpp 文件的编译
+ 编译效率提升 ： 在大项目中，头文件可能会被成千上万次包含，而 #ifndef 机制可以减少不必要的代码编译，加快编译速度
***
+ 使用 #pragma once
*** 
    //在头文件中
    #pragma once  // 让编译器只编译一次该头文件

    int add(int a, int b);

#pragma once 是非标准的，但被几乎所有主流编译器（GCC、Clang、MSVC）支持，或许一些老旧的编译器不支持，但代码更简洁，可能提高编译速度
***